\documentclass{beamer}

%\usepackage{movie15}
\usepackage{verbatim}
\usepackage{amsmath}

\usepackage{tikz}
\usetikzlibrary{shapes, arrows, calc}

\usepackage[T1]{fontenc}
\usepackage[ansinew]{inputenc}
\usepackage{lmodern} 
\usepackage{textcomp}

\useoutertheme{infolines} 
\setbeamertemplate{navigation symbols}{}
\setbeamertemplate{items}[ball] 
\setbeamertemplate{blocks}[rounded][shadow=true] 

%\usetheme{Boadilla}
\usetheme{Madrid}
\usecolortheme{whale}

\author[Boshen Chen]{Boshen Chen \\{\small Supervised by: Dr.\ Andrea Raith, Olga Perederieieva}}

\title[Faster Shortest Path Computation]{Faster Shortest Path Computation for Traffic Assignment}

%\subtitle[]{}

\institute[UoA]{
    Department of Engineering Science\\
    University of Auckland\\
}

\begin{document}

\begin{frame}[plain]
    \titlepage
\end{frame}

%\begin{frame}{Contents}
%    \tableofcontents
%\end{frame}

\section{Project motivation - Traffic Assignment}
\begin{frame}[Traffic Assignment]
    % A transportation network where some of the nodes have traffic supplies and demands that we wish to satisfy.
    % Easy if travel time on arcs is fixed,
    % but in reality they get congested once there are lots of traffic,
    % so we have a non-linear cost function to capture the congestion effect.
    % One well-established method of solving of this is the all or nothing assignment:
    % we either send traffic all at once via the shortest path or we send none.
    % Via the shortest path because we are selfish that we want to go to a place as fast as possible,
    % this traffic assignment model is an iterative algorithm where
    % first we assign traffic to the arcs with the 
    % free time,
    % then we recalculate the arcs travel times as now they have traffic flows,
    % they become congested,
    % then we repeat and reassign the traffics and update the arc costs,
    % eventually ending up with equilibrium.
    % As you can see during the process there will be lots of iterations if the supplies and demands are complicated and the graph is large,
    % and each iteration we need to find the shortest path between every origin destination pair,
    % so many shortest path calculations, speeding 1 will cumulatively making the solving much more faster
    % thus we wish to find a faster shortest path algorithm compared to the standard Bellman-Ford or Dijkstra's algorithm.
    \begin{itemize}[<+->]
        \item transportation network with supply and demand nodes
        \item arcs have non-linear costs for capturing congestion effects
        \item all-or-nothing assignment
            \begin{itemize}
                \item send traffic all at once to a node via the shortest path
            \end{itemize}
    \end{itemize}

    \pause
    \begin{center}
        \tikzstyle{block} = [rectangle, draw, text width=.6\paperwidth, text centered, rounded corners, minimum height=2em]
        \tikzstyle{line} = [draw, -latex']
        \begin{tikzpicture}[node distance=4em]
            \node [block] (first) {Initialise: all-or-nothing assignment on shortest path with free flow travel times};
            \pause

            \node [block, below of=first] (second) {Update arc travel times};
            \path [line] (first) -- (second);
            \pause

            \node [block, below of=second] (third) {Load demand: all-or-nothing assignment on \only<1-10>{shortest path}\only<11>{\underline{shortest path}} computed from new arc travel times};
            \path [line] (second) -- (third);
            \pause

            \node [block, below of=third] (fourth) {Check stopping criterion (equilibrium)};
            \path [line] (third) -- (fourth);
            \pause

            \path [line] (fourth.west) -- ($(fourth.west)-(0.8,0)$) -- ($(second.west)-(0.8,0)$) -- (second.west);
            %\path [line] ($(second.west)-(0.8,0)$) -- (second.west);
            %\path [line] ($(third.west)-(0.8,0)$) -- (third.west);
        \end{tikzpicture}
    \end{center}

\end{frame}
\begin{comment}
\begin{frame}{Transportation forecasting}

    \begin{columns}
        \begin{column}{0.5\paperwidth}
            \begin{center}
                \tikzstyle{block} = [rectangle, draw, text width=10em, text centered, rounded corners, minimum height=2em]
                \tikzstyle{line} = [draw, -latex']
                \begin{tikzpicture}[node distance=4em]
                    \pause

                    \node [block] (first) {Trip Generation};
                    \pause

                    \node [block, below of=first] (second) {Trip Distribution};
                    \path [line] (first) -- (second);
                    \pause

                    \node [block, below of=second] (third) {Mode Choice};
                    \path [line] (second) -- (third);
                    \pause

                    \node [block, below of=third] (fourth) {Traffic Assignment};
                    \path [line] (third) -- (fourth);
                    \pause

                    \path [line] (fourth.west) -- ($(fourth.west)-(0.8,0)$) -- ($(first.west)-(0.8,0)$) -- (first.west);
                    \path [line] ($(second.west)-(0.8,0)$) -- (second.west);
                    \path [line] ($(third.west)-(0.8,0)$) -- (third.west);
                \end{tikzpicture}
            \end{center}
        \end{column}

        %\begin{column}{0.5\paperwidth}
        %    What has been done in the past \ldots
    % mo%tivation, transportation forecasting and the 4 stage modelling process
    % us%e figure
        %    \begin{itemize}
        %        \item trip generation
        %        \item trip distribution
        %        \item mode choice
        %        \item traffic assignment
        %    \end{itemize}

        %    Traffic assignment
        %    \begin{itemize}
        %        \item how its solved
        %        \item concept of user equilibrium
        %        \item shortest path calculations
        %        \item link cost, lots of iterations, each iteration lots of shortest path calculations
        %    \end{itemize}
        %\end{column}
    \end{columns}

\end{frame}
\end{comment}

\section{Solving the Traffic Assignment problem - faster shortest path calculations}
\begin{frame}[shrink]{The Graph - 93,135 Origin-Destinations Pairs}
    % Let me go through the steps I took to find a faster algorithm,
    % on this graph with more than 93,000 origin destination pairs
    \begin{center}
        \includegraphics[page=1,width=\paperwidth, height=\paperheight, keepaspectratio,trim=0 120px 48px 120px,clip]{img/chicago_dijkstra_animation}
    \end{center}
\end{frame}

\begin{comment}
\begin{frame}{Faster shortest path calculations}

    What exist and what I have done \ldots
    \begin{itemize}
        \item Bellman Ford - label correcting algorithm
        \item Dijkstra - label setting algorithm
            \begin{itemize}
                \item different data structures - Heap trees and their advantages
            \end{itemize}
        \item bidirectional
        \item A* search
        \item bidirectional A* search
        \item preprocessing
    \end{itemize}

\end{frame}
\end{comment}

\foreach \n in {1,...,7}{
    \begin{frame}[shrink]{Dijkstra's Algorithm}
        \begin{center}
            \includegraphics[page=\n,width=\paperwidth, height=\paperheight, keepaspectratio,trim=0 120px 48px 120px,clip]{img/chicago_dijkstra_animation}
        \end{center}
    \end{frame}
}

% can talk about data strucutre here
\begin{frame}{Dijkstra's Algorithm - Priority Queue}
    \begin{itemize}
        \item Pointer based Heap (C++ boost library)
            \begin{itemize}
                \item Binomial
                \item Pairing
                \item Binary
                \item Ternary
                \item Skew
                \item Fibonacci
            \end{itemize}
        \item (red-black) binary search tree (C++ STL <set>)
        \item array based Heap (C++ STL <priority\_queue>) \only<2>{$\leftarrow$ winner}
    \end{itemize}
\end{frame}

% since we have a origin and a destination, 
% we can calculate from the two ends 

\foreach \n in {1,...,7}{
    \begin{frame}[shrink]{Bidirectional Dijkstra's Algorithm}
        \begin{center}
            \includegraphics[page=\n,width=\paperwidth, height=\paperheight, keepaspectratio,trim=0 120px 48px 120px,clip]{img/chicago_bidirect_animation}
        \end{center}
    \end{frame}
}

\foreach \n in {1,...,5}{
    \begin{frame}[shrink]{A* Search}
        \begin{center}
            \includegraphics[page=\n,width=\paperwidth, height=\paperheight, keepaspectratio,trim=0 120px 48px 120px,clip]{img/chicago_astar_animation}
        \end{center}
    \end{frame}
}

\foreach \n in {1,...,7}{
    \begin{frame}[shrink]{Bidirectional A* search}
        \begin{center}
            \includegraphics[page=\n,width=\paperwidth, height=\paperheight, keepaspectratio,trim=0 120px 48px 120px,clip]{img/chicago_astar_bidirect_animation}
        \end{center}
    \end{frame}
}

\section{Results - speed ups}
\begin{frame}
    \includegraphics[width=\paperwidth, height=\paperheight, keepaspectratio, trim=0 0 0 60pt, clip]{img/runtime}
    \pause

    \tikzstyle{block} = [circle, draw, inner sep=0pt,minimum size=1pt]
    \begin{tikzpicture}[overlay, shift={(1.6,0)}]
        \node [block, minimum size= 1.4pt] (a) {};
        \node [block, minimum size= 7.9pt] (b) [xshift=-0.1cm, right of=a] {};
        \node [block, minimum size= 4.3pt] (c) [xshift=0.4cm, right of=b] {};
        \node [block, minimum size= 93pt] (d) [xshift=6.7cm, right of=c] {};

        \node [above] at (a.north) {\tiny 10 iters};
        \node [above] at (b.north) {\tiny 27 iters};
        \node [above] at (c.north) {\tiny 126 iters};
        \node [above] at (d) {\tiny 25 iters};
    \end{tikzpicture}
\end{frame}

\begin{frame}{Future Works}
    \pause
    \begin{itemize}[<+->]
        \item preprocessing
            \begin{itemize}
                \item A* search combined with landmark distances
            \end{itemize}
        \item use information from previous iteration
            \begin{itemize}
                \item Incremental heuristic search - Lifelong Planning A*
                % fix shortest path tree if altered somewhere
            \end{itemize}
    \end{itemize}
\end{frame}
\end{document}
