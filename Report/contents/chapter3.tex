\chapter{Implementation Details} \label{chap:implementation}
\todo[inline]{Be more formal, to colloquial at the moment}

The previous chapter have described all the algorithms that are implementation for this report. 
In this chapter, we seek and research the specific implementation details that make the algorithms run faster.

Note the traffic assignment algorithms have already been implemented by the co-supervisor of this report in a Object Oriented C++ program.
The programs includes Frank-Wolfe, Path Equilibration,
label correcting algorithm and many more.

\section{Graph Storage}
The graph storage is implemented as a Forward Star data structure.
Forward Star stores a network compactly with $O(V+E)$ space.
It allows $O(1)$ access for any nodes in the graph and $O(1)$ access
for all arcs emanating from a random node,
which are the requirements for the generic shortest path algorithms.
Information about Forward Star can be found in \citep{Sheffi}.

\section{Priority Queue Implementations}
%\todo[inline]{explain how this relates to previous results (one is STL and one is Boost, need to be much clearer}
\todo[inline]{we can also use std::set, which uses binary search tree and provides $O(log(n))$ search and keeps minimum element on top of the tree}

Various implementations of the priority queues exist,
they include the array based heap implementation (std::priority\_queue) from the C++ standard template library (STL) and 6 different variants of heap implementations from the C++ Boost library.
Each implementation may have some advantages than the other,
for example faster tree balancing, faster Extract-Min or Delete etc.

We first examine the 6 variants of Heap implementations from the C++ Boost Heap Library shown in Table~\ref{table:heaps} \citep{BoostHeap}.
Where N is the number of elements in the Heap tree, and all time complexities are measured in amortized time,
i.e.\ the average run time if the operation is run for a long period of time,
average out worse case and best case.
\begin{table}[H]
    \centering
    \begin{tabular}{cccccc}
        & top() & push()    & pop()     & increase() & decrease() \\
        d-ary (Binary)  & O(1)  & O(log(N)) & O(log(N)) & O(log(N))  & O(log(N))  \\
        d-ary (Ternary) & O(1)  & O(log(N)) & O(log(N)) & O(log(N))  & O(log(N))  \\
        Binomial        & O(1)  & O(log(N)) & O(log(N)) & O(log(N))  & O(log(N))  \\
        Fibonacci       & O(1)  & O(1)      & O(log(N)) & O(1)       & O(log(N))  \\
        Pairing         & O(1)  & O($2^{2*\log(\log(N))}$) & O(log(N)) & O($2^{2*\log(\log(N))}$) & O($2^{2*\log(\log(N))}$) \\
        Skew            & O(1)  & O(log(N)) & O(log(N)) & O(log(N)) & O(log(N))   
    \end{tabular}
    \caption{C++ Boost Heap Implementations with Comparison of Amortized Complexity}
    \label{table:heaps}
\end{table}

We are interested in using Boost library Heaps rather than the STL library Heap is due to one reason:
the decrease (or increase) function.
The decrease (or increase) function is referred as the decrease-key (or increase-key) operation mentioned in Section~\ref{chapter:labelsettingalgorithm},
which updates the value of the key in the Heap tree.
Decrease-key is used for a min-heap and increase-key for a max-heap tree.
For Dijkstra's algorithm,
often nodes are scanned multiple times in the label updating step,
instead of adding the node again into the Heap tree,
we can use decrease-key on the node,
updating its distance label.
This means we can reduce the size of the Heap tree and run time by using decrease-key
rather than adding the same node with different distance label in the queue again.

In table~\ref{table:heaps},
we can observe the Fibonacci Heap has a very interesting time complexity:
constant amortized time for the push, pop and increase-key operation time.
But the fact is,
we do not know how much constant time it really uses behind its big O.
It is reported that Fibonacci Heaps only outperforms other Heaps when the graph is very dense\todo{this is going to be hard to find a good reference, all reports are from Stackoverflow.com},
but it is worth to experiment Fibonacci Heap as well as all other Heaps.

The STL library Heap is still going to be implemented and tested.
The STL library Heap does not support the decrease-key operation but
should not be a worry.
This is due to the fact that if a node has been added to the Heap more than once,
the node with smaller distance label is always going to be removed from the queue and update its successors first,
the same node with larger distance label will therefore not update its successors.

%\todo[inline]{more details about Fibonacci, why good in theory not in practice}

C++ Boost Library Heaps are implemented as max-heaps,
which means in order to use the Fibonacci O(1) increase-key function,
we need to negate the distance labels when we add them into the Heap.


