\chapter{Solving the Shortest Path Problem} \label{chap:solvingspp}
The previous chapter describes the details of the traffic assignment problem.
Algorithms such as the path equilibration algorithm used to solve the traffic assignment require to solve the shortest path problem on a static graph, where the graph does not change while the shortest path is getting solved.
Thus in this chapter, we investigate 
various standard algorithms which have been developed 
to address the problem of finding the shortest path.
This chapter states notation and definitions for the shortest path problem and discusses
the theory of solving it.
Shortest path algorithms that are applicable for the traffic assignment problem are summarised,
including the discussion of their advantages and drawbacks.

\section{Notations and definitions}
The Shortest Path Problem (SPP) is the problem of finding the shortest path from a given origin to some destination.
There are two types of SPP that are going to
be analysed in this chapter:
a single-source and a point-to-point SPP.  
The single-source SPP wishes to find all of the shortest paths originating from a origin,
and the point-to-point SPP wishes to find one shortest path between an origin and destination.
More emphasis is going to be put on the point-to-point SPP required by the path equilibration algorithm described in the previous chapter.
%The Frank-Wolfe algorithm in the TA involves
%solving the single-source SPP by finding shortest path going from one origin to every other destinations of the network.
%The Path Equilibration method in the TA
%Solving the point to point SPP solves from one origin to a specific destination and is used in the Path Equilibration method. 

%When solving SPP for a normal road network,
%different measurements such as distance and travel exist for the road length.
%But in traffic assignment,
%the road length is measured in a non-decreasing travel time function,
%which encapsulates information such as traffic flow, road capacity and travel speed.
%This travel time function (Figure~\ref{fig:flowfunction}) is always non-negative so taking advantage of this helps the selection of algorithms that uses this property.

We present the notation mainly borrowed from \citet{Cormen} and \citet{Klunder}.
We denote $ G = ( N, A ) $ a weighted, directed graph,
where $ N $ is the set of nodes (origins, destinations, and intersections)
and $ A $ the set of arcs (links).
We say $ A $ is a subset of the set $ \{ (u, v)\, | \, u, v \in N \} $ of all ordered pairs of nodes.
We denote the link (arc) cost function $ c : A \rightarrow \mathbb{R} $ which assigns a cost (travel time) to any arc $ (u,v) \in A $.
We write the costs of link $(u, v)$ as: $ c((u, v)) = c_{uv} $.

The path $P$ inside a transportation network has to be a directed simple path, 
which is a sequence of nodes and arcs $ (u_1, (u_1, u_2), u_2, \ldots , (u_{k-1}, u_k), u_k ) $
such that $ (u_i, u_{i+1}) \in A$ for $i = 1,\ldots,k-1$ and $u_i \neq u_j$ for all $ 1 \leq i < j \leq k$.
Note $u_1$ is the origin and $u_k$ is the destination of the path $P$, $u_1$ and $u_k$ together is called an O-D pair for this path.
For simplicity, we denote $s$ to be the source (origin) and $t$ to be the target (destination) for any path $P$.
%Finally we denote cost of the whole path $C(P) := \sum_{(u,v)\in P} c_{vw}$.

In traffic assignment,
the origin and destination nodes used for traffic supply and demand are referred as zone nodes.
The zones are conceptual nodes that are untravellable in the network,
which means a path between two zone nodes must not pass through another zone node.
Figure~\ref{fig:zonenodes} demonstrates how a zone node behaves under different conditions.
If the zone is an origin node, then only out-going arcs are allowed.
If it is a destination node, then only in-coming arcs are allowed.
And if it is neither, then no arcs can pass through it, otherwise an incorrect path is going to be created.
\begin{figure}[!ht]
    \tikzstyle{main node} = [circle, draw, text centered, minimum height=2.5em]
    \tikzstyle{line} = [->, draw]
    \centering
    \begin{subfigure}[b]{0.4\textwidth}
        \centering
        \begin{tikzpicture}[>=stealth', line width=1pt, auto, node distance=3cm]
            \node[main node] (zone) {zone};
            \node[main node] (1) [below left of=zone] {1};
            \node[main node] (2) [below right of=zone] {2};
        %\path [line, red] (1) -- (zone);
            \path [line, green!80!black] (zone) -- (2);
            \path [line, green!80!black] (1) -- (2);
            %\node (text) [yshift=-5em,above of=zone] {origin node};
        %\node at ($(zone) !.5! (2)$) {$\mathbin{\tikz [x=1.4ex,y=1.4ex,line width=.3ex, black] \draw (0,0) -- (1,1) (0,1) -- (1,0);}$};
        \end{tikzpicture}
        \caption{zone as origin node of a path}
    \end{subfigure}
    \quad
    \begin{subfigure}[b]{0.4\textwidth}
        \centering
        \begin{tikzpicture}[>=stealth', line width=1pt, auto, node distance=3cm]
            \node[main node] (zone) {zone};
            \node[main node] (1) [below left of=zone] {1};
            \node[main node] (2) [below right of=zone] {2};
            \path [line, green!80!black] (1) -- (zone);
        %\path [line, red] (zone) -- (2);
            \path [line, green!80!black] (1) -- (2);
            %\node (text) [yshift=-5em,above of=zone] {destination node};
        %\node at ($(zone) !.5! (2)$) {$\mathbin{\tikz [x=1.4ex,y=1.4ex,line width=.3ex, black] \draw (0,0) -- (1,1) (0,1) -- (1,0);}$};
        \end{tikzpicture}
        \caption{Zone as destination node of a path}
    \end{subfigure}

    \vspace{1cm}
    \begin{subfigure}[t]{\textwidth}
        \centering
        \begin{tikzpicture}[>=stealth', line width=1pt, auto, node distance=3cm]
            \node[main node] (zone) {zone};
            \node[main node] (1) [below left of=zone] {1};
            \node[main node] (2) [below right of=zone] {2};
        %\path [line, green!80!black] (1) -- (zone);
        %\path [line, red] (zone) -- (2);
            \path [line, green!80!black] (1) -- (2);
            %\node (text) [yshift=-5em,above of=zone] {neither};
        %\node at ($(zone) !.5! (2)$) {$\mathbin{\tikz [x=1.4ex,y=1.4ex,line width=.3ex, black] \draw (0,0) -- (1,1) (0,1) -- (1,0);}$};
        \end{tikzpicture}
        \caption{Zone as neither origin nor destination node of a path}
    \end{subfigure}
    \caption{Behaviour of arcs on zone nodes acting as origin, destination or neither.}
    \label{fig:zonenodes}
\end{figure}

\section{Generic shortest path algorithm}
A family of algorithms exists for solving the shortest path problem.
In this section the generic case for these algorithms is described.

This family of algorithms aims to find a 
distance label vector ($d_1, d_2,\dots, d_v$),
and the corresponding shortest path between each origin and destination \citep{Klunder}.
Each $d_v$ tracks the least distance of the path going from the origin $s$ to a node $v$.
%We denote $d_v = \infty$ if no path $P$ from $s$ to $v$ has been found.
A shortest path $P$ is optimal when it satisfies the following conditions:
\begin{align}
    d_v \leq d_u + c_{uv}, \quad \forall(u,v) \in A, \label{eq:Bellman1}\\
    d_v  =   d_u + c_{uv}, \quad \forall(u,v) \in P. \label{eq:Bellman2}
\end{align}
The inequalities~(\ref{eq:Bellman1}) are called Bellman's condition \citep{Bellman}.
To solve the shortest path problem,
we wish to find a label vector $d$ which satisfies Bellman's condition for all of the nodes in the graph.
In the generic shortest path algorithm,
it continuously finds a node that violates Bellman's condition (\ref{eq:Bellman1}) and updates its distance label with the path that has a shorter distance that connects to it.
All shortest paths connecting the origin $s$ to all other nodes in $N$ are guaranteed to be found when both Equation~\eqref{eq:Bellman1} and \eqref{eq:Bellman2} hold.
It is important to note that arcs with negative costs are permitted,
but the graph must not contain negative cycles.

Algorithms for solving the SPP generally use some kind of queue $\mathcal{Q}$ to store the label distances $d_v$ ($\forall v \in N$).
In the label vector,
a node $v$ is said to be 
\begin{itemize}
    \item \emph{unvisited} when $d_v = \infty$,
    \item \emph{scanned} when $d_v \neq \infty$ and it is still in the queue,
    \item \emph{labelled} when the node has been retrieved from the queue and its distance label cannot be improved further.
\end{itemize}
If a node $v$ is labelled then its distance value is guaranteed to represent the shortest path distance from $s$ to $v$.

To keep track of the shortest path found so far for node $v$,
we denote $p_v$ the predecessor of node $v$.
The shortest path can be constructed by following the predecessor of the destination node $t$ back to the origin node $s$.
We set $p_s = -1$ to indicate that node $s$ does not have a predecessor.

Algorithm~\ref{algo:gsp} \citep{Klunder} describes the generic shortest path algorithm mentioned above,
with an extra constraint required when solving a TA problem: travelling through zone nodes is not permitted.
In essence, this algorithm repeatedly selects node $v \in \mathcal{Q}$ and 
updates its distance label if Bellman's condition is violated for all its out-going arcs.

\begin{algorithm}
    \caption{The Generic Shortest Path Algorithm}
    \label{algo:gsp}
    \begin{algorithmic}[1]
        \Procedure{GenericShortestPath}{$s$}
        \State $\mathcal{Q} \gets \mathcal{Q} \cup \{s\}$ \Comment{initialise queue with source node}
        \State $p_s \gets -1$ \Comment{origin has no predecessor}
        \State $d_s \gets 0$
        \ForAll {$ u \in N : u \neq s $} \Comment{all nodes are unvisited except the source}
        \State $d_u \gets \infty$
    \EndFor

    \While{ $\mathcal{Q} \neq \emptyset$ }
    \State $ u \gets \text{next}(\mathcal{Q}) $ \Comment{select next node}
    \State $ \mathcal{Q} \gets \mathcal{Q} \setminus \{u\} $
    \If{$u \text{ is not zone } \text{\textbf or } u = s$}
    \ForAll {$v : (u, v) \in A$} \Comment{check Bellman's condition for all successors of $u$}
    \If {$d_u + c_{vw} < d_v$}
    \State $d_v \gets d_u + c_{vw}$
    \State $p_v \gets u$
    \If {$v \notin \mathcal{Q}$} 
    \State $\mathcal{Q} \gets \mathcal{Q} \cup \{v\}$ \Comment{add node $v$ to queue if unvisited}
\EndIf
                    \EndIf
                \EndFor
            \EndIf
        \EndWhile
    \EndProcedure
\end{algorithmic}
\end{algorithm}

Algorithm~\ref{algo:gsp} is generic because 
the rule for selecting the next node $u$ (the `next' function in line 8) and
the implementation of the queue $\mathcal{Q}$ are unspecified.
Different algorithms use different rules and implementations to give 
either the one-source or the point-to-point shortest path algorithm \citep{mplomer}.
The rules and implementations are described in the following sections to give concrete algorithms for solving the SPP.

\section{Bellman-Ford-Moore algorithm} \label{section:labelcorrectingalgorithm}
When some specific strategy is applied to maintain the queue $\mathcal{Q}$
and arc costs are allowed to have negative values,
the generic shortest path algorithm is addressed as the label correcting algorithm,
or Bellman-Ford-Moore algorithm (credited to \citet{Bellman, Ford} and \citet{Moore}).

The algorithm is addressed as the label correcting algorithm
because the distance labels do not get permanently labelled when a node $u$ is retrieved from the queue,
the distance label of node $u$ may be `corrected' by some other node $v$ when $v$ is retrieved from the queue and re-updates $u$.

One specific strategy for maintaining the queue is described in \citet{Sheffi}.
This strategy is shown to be very effective for computing shortest path on transportation networks.
It avoids duplicating computation by not physically moving (or reordering) nodes in the queue,
as well as not adding nodes to the queue if they are already in it.
The nodes in the queue are simply processed from front to end.
Scanned nodes are firstly added to the end of the queue,
and if the scanned node is already in the queue,
then the node is put in front of the queue so they can be processed first.
This strategy, developed by \citet{Pape}, transforms the queue into a \emph{double-ended queue} (or \emph{deque}).

In order to satisfy the Bellman's condition for all arcs,
the algorithm has to scan all arcs $|N|-1$ times,
resulting in a run time of $O(|N||A|)$\footnote{Big-$O$ notation: if $f \in O(g)$, then $f \leq g$. This means $f $ does not grow asymptotically faster than $g$, it describes the worst-case scenario of $f$. In context, run time of $O(|N||A|)$ means the performance of the algorithm is directly proportional to the number of nodes multiplied by the number of arcs.}.

\section{Dijkstra's algorithm} \label{sec:dijkstra}
The classic algorithm for solving the single-source shortest path problem is the label setting algorithm published in \citet{Dijkstra}.
The algorithm is addressed as label setting because when the next node $u$ is retrieved from the queue,
it gets permanently labelled,
The shortest path going to this node is solved and 
the distance label represents the length of this shortest path.
In order to achieve label setting, 
it is assumed that all arc costs are non-negative,
and the queue $\mathcal{Q}$ is modified to always have the minimum distance label in the front.
This modification allows the algorithm to visit every node in the graph exactly once,
where the next node is labelled in the order of non-decreasing distance labels.

The advantage of this algorithm is that,
when the next labelled node is the destination node,
the algorithm can be stopped for the point-to-point shortest path problem.
This reduces the total run time as the algorithm does not have to scan the entire graph,
which is desirable for the point-to-point shortest path problem involved in the path equilibration algorithm described in the previous chapter.

\subsection{Priority queues} \label{sec:pq}
The run time performance of Dijkstra's algorithm depends heavily on the implementation of the queue $\mathcal{Q}$ for storing the scanned nodes.
\citet{Cormen} suggests the use of priority queues.
Priority queues are a collection of data structures
that keep track of elements using an extra priority attribute.
This allows an element with a higher priority to be processed before an element with a lower priority when iterating through the queue.
%The first element of the priority queue always have the highest priority.
In the shortest path problem, the priority is measured by the distance labels, where smaller distance labels have higher priority.
Priority queues that have smaller values come first are name min-priority queues, whereas larger values come first are named max-priority queues.

Algorithm~\ref{algo:p2pdijkstra} shows the use of the min-priority queue in Dijkstra's algorithm.
The min-priority queue has three main operations: Insert, Extract-Min and Decrease-Key.
The Insert operation (line $2$ and $17$) is used for adding new nodes to the queue.
The Extract-Min operation (line 8) is used for getting the element with the minimum distance label.
The Decrease-Key (line 19) operation is used to decrease the value of the distance label if the node is already in the queue.

\begin{algorithm}[!ht]
    \caption{Point to Point Dijkstra's Algorithm}
    \label{algo:p2pdijkstra}
    \begin{algorithmic}[1]
        \Procedure{Dijkstra}{$s, t$}
        \State $\text{Insert}(\mathcal{Q}\text{ , u})$ \Comment{initialise priority queue with source node}
        \State $p_s \gets -1$ \Comment{origin has no predecessor}
        \State $d_s \gets 0$
        \ForAll {$ u \in N : u \neq s $} \Comment{all nodes are unvisited except the source}
        \State $d_u \gets \infty$
    \EndFor

    \While{ $\mathcal{Q} \neq \emptyset$ }
    \State $ u \gets \text{Extract-Min}(\mathcal{Q}) $ \Comment{select next node with minimum value}
    \If{$u = t$}
    \State $\text{Terminate Procedure}$ \Comment{finish if next node is the destination}
\EndIf
    \If{$u \text{ is not zone } \text{\textbf or } u = s$}
\ForAll {$v : (u, v) \in A$} \Comment{check Bellman's condition for all successors of $u$}
\If {$d_u + c_{vw} < d_v$}
\State $d_v \gets d_u + c_{vw}$
\State $p_v \gets u$
\If {$v \notin \mathcal{Q}$} 
\State $\text{Insert}(\mathcal{Q}, v)$ \Comment{add node $v$ to queue if unvisited}
\Else
\State $\text{Decrease-Key}(\mathcal{Q}, v)$ \Comment{else update value of $v$ in queue}
    \EndIf
\EndIf
                \EndFor
            \EndIf
        \EndWhile
    \EndProcedure
\end{algorithmic}
\end{algorithm}

According to \citet{Cormen},
a min-priority queue can be implemented via an array, a binary min-heap or a binary search tree,
where each implementation gives different run time performances.

In the array implementation,
the distance labels are stored in an array where the $n^{\text{th}}$ position gives the distance value for node $n$.
Each Insert and Decrease-Key operation in this implementation takes $O(1)$ time, and each Extract-Min takes $O(|N|)$ time (searching through the entire array), giving a overall time of $O(|N|^2 + |A|)$.

A binary min-heap is a binary tree that satisfies the min-heap property:
the value of each node is smaller or equal to the value of its child nodes.
\citet{Cormen} shows that the performance of Dijkstra's algorithm can be improved with a binary min-heap if the graph is sufficiently sparse.
In this implementation, each Insert and Extract-Min operation takes $O(\log(|N|))$ time in total of $|N|$ times,
and the Decrease-Key operation takes $O(\log(|N|))$ time in total of $|A|$ times.
The total running time of Dijkstra's algorithm using min-priority is therefore $O((|N|+|A|)\log(|N|))$,
which is an improvement compared to the array implementation.

The running time can be further improved using a Fibonacci heap developed by \citet{Fredman}.
Historically, the development of the Fibonacci heap was motivated by the observation that Dijkstra's algorithm typically uses more Decrease-Key operations compared to Extract-Min operations.
In Fibonacci heap, each of the $|N|$ Extract-Min operation takes $O(\log(|N|))$ amortized time\footnote{Amortized time gives how much time is taken in total when an operation is repeated a million times. For example with different inputs, run time is averaged between the worst-case and the best-case.}
and each of the $|A|$ Decrease-Key operation takes only $O(1)$ amortized time.
The total running time is therefore $O(|N| \log(|N|)+|A|)$,
which is a further improvement.

Min-priority queue can be implemented as a binary search tree.
In a binary search tree, the worst case for insertion, deletion and search for an element all have $O(\log(|N|))$ time.
Dijkstra's algorithm can easily be modified to accommodate a binary search tree:
when label distance of a node needs to be updated,
we remove that node from the tree and insert a new one with the updated value (this is analogous to the Decrease-Key operation).
Dijkstra's algorithm using a binary search tree runs $O((|N|+|A|)\log(|N|))$ time in the worst case, which is the same compared to the min-binary heap implementation.

In this project, all of the mentioned priority queue implementations are tested.
The results can be found in Section~\ref{sec:pq_results}.

\section{Bidirectional Dijkstra's algorithm} \label{section:bidirectional}
Dijkstra's algorithm can be imagined to be searching radially outward in a circle with the origin in the centre and destination on the boundary.
Likewise, Dijkstra's algorithm can be used on the reverse graph (all arcs reversed in the graph) from the destination node.
Thus Dijkstra's algorithm can be started from the origin and destination at the same time.
The motivation for doing this is because the number of scanned nodes can be reduced when searching bidirectionally:
two smaller circles growing outward radially instead of a larger one.
Figure~\ref{fig:bidirect} demonstrates the difference in search area between Dijkstra's algorithm and its bidirectional version on a planar graph using Euclidean distances.
It is easy to see that the total search area of the bidirectional version is a lot smaller.

\begin{figure}[H]
    \tikzstyle{main node} = [circle, draw, text centered, minimum height=2.5em]
    \tikzstyle{big circle} = [circle, draw, dashed, text centered, minimum height=8em]
    \tikzstyle{small circle} = [circle, draw, dashed, text centered, minimum height=5em]
    \centering
    \begin{subfigure}[t]{.4\textwidth}
        \centering
        \begin{tikzpicture}[>=stealth', line width=1pt, auto, node distance=2cm]
            \node [main node] (s)  {s};
            \node [main node] (t) [right of=s] {t};

            \node [big circle] at (s) {};
        \end{tikzpicture}
        \caption{Dijkstra's algorithm}
    \end{subfigure}
    \begin{subfigure}[t]{.4\textwidth}
        \centering
        \begin{tikzpicture}[>=stealth', line width=1pt, auto, node distance=2cm]
            \node [main node] (s) {s};
            \node [main node] (t) [right of=s] {t};

            \node [small circle] at (s) {};
            \node [small circle] at (t) {};
            \node [big circle, white] at (s) {};
        \end{tikzpicture}
        \caption{bidirectional}
    \end{subfigure}
    \caption{Difference between the scanned area of label setting and its bidirectional version}
    \label{fig:bidirect}
\end{figure}

It is common to conclude that the shortest path is found when the two searches meet somewhere in the middle,
but this is not actually the case.
There may exist another arc connecting the two frontiers of the searches that has a shorter path (proof can be found in \citet{Klunder}).
The correct termination criteria was first designed and tested by \citet{Pohl} based on research presented by \citet{Dantzig, Nicholson} and \citet{Dreyfus}.
The procedure and algorithm are summarised in \citet{Klunder}, and the termination criteria is presented by \citet{Pohl}.

The bidirectional search algorithm is shown in Algorithm~\ref{algo:bidirectional}.
Two independent Dijkstra's algorithms are performed alternatively on the forward and reverse graph (forward and backward search).
The two searches terminate when some node is permanently labelled in both directions.
Once the searches is terminated,
the correct shortest path is found by looking for an arc connecting the frontiers of the two searches that may yield a shorter path.
This extra requirement increases the run time significantly, 
where searches are needed for all arcs that connect all labelled nodes in the forward search to all labelled nodes in the backward search.

Note in Algorithm~\ref{algo:bidirectional},
$\mathcal{R}^s$ contains the set of nodes $v$ in the forward search that are permanently labelled from the origin node $s$,
$\mathcal{R}^s$ have corresponding label distances $d_v^s$.
Similarly, $\mathcal{R}^t$ contains the set of nodes $v$ in the backward search that are permanently labelled from the destination node $t$,
$\mathcal{R}^t$ have corresponding label distances $d_v^t$.

\begin{algorithm}[!ht]
    \caption{Bidirectional Dijkstra's Algorithm}
    \label{algo:bidirectional}
    \begin{algorithmic}[1]
        \Procedure{Bidirectional}{$s, t$}
        \State Execute one iteration of the forward algorithm.
        If the next node $u$ is already labelled permanently by the 
        backward algorithm $(u\in\mathcal{R}^t)$, go to step 3.
        Else, go to step 2.
        \State Execute one iteration of the backward algorithm.
        If the next node $u$ is already labelled permanently by the
        forward algorithm $(u\in\mathcal{R}^s)$, go to step 3.
        Else, goto step 1.
        \State Find $\min\{\min\{d_v^s + c_{vw} + d_w^t | v \in \mathcal{R}^s, w \in \mathcal{R}^t, (v, w) \in A\}, d_u^s + d_u^t\}$, which gives the length of the correct shortest path between $s$ and $t$.
    \EndProcedure
\end{algorithmic}
\end{algorithm}

In recent years,
\citet{Goldberg05} improved the bidirectional algorithm using a better termination condition,
where step 3 of Algorithm~\ref{algo:bidirectional} is embedded during the searches.
The termination condition is summarised as follows.
During the forward and backward search,
we maintain an extra variable, $\mu$, to present the length of the shortest path seen so far during the forward and backward search.
Initially $\mu = \infty$.
When an arc $(v,w)$ is visited by the forward search and node $w$ has been scanned in the backward search, or vice versa,
we know the shortest path $s-v$ and $w-t$ have lengths $d_v^s$ and $d_w^t$ respectively.
During the search, if $\mu > d_v^s + c_{vw} + d_w^t$ then the current connected path $s-v-w-t$ is shorter than the one before, 
so we update $\mu = d_v^s + c_{vw} + d_w^t$.
The algorithm terminates when a node is permanently labelled in both directions,
where $\mu$ gives the length of the shortest path.

\citet{GoldbergEPP} showed and proved a stronger termination condition on top of the previous one.
The searches can be stopped if the sum of the two top priority queue values is greater than $\mu$
\[
    \text{top}_f + \text{top}_r \geq \mu.
\]
Here $\text{top}_f$ and $\text{top}_r$ are the next minimum distance labels that have not been labelled in the forward and backward search.

Overall, the bidirectional version of Dijkstra's algorithm can be faster than the single direction one if it is implemented correctly using the best termination criterion.

\section{A* Search}\label{section:A*}
Dijkstra's algorithm can be imagined as growing the shortest path tree radially out from the origin,
the location of the destination does not affect how the shortest path tree is grown.
In fact, heuristic estimates can be used to guide the shortest path tree towards the destination,
forming an ellipsoid shape.
The use of heuristic estimates was first described by \citet{Astar},
where the algorithm is given the name A* search.
A* search is a goal directed search where the direction of search is aimed towards the destination.

%In traditional road networks,
%straight Euclidean distances are used for the heuristic estimates.

Let $h_v$ be the heuristic estimate for the shortest path distance between node $v$ to destination $t$.
We apply Bellman's condition such that an optimal solution exists, that is 
\begin{align}
    &h_v \leq h_u + c_{uv} \quad \forall(u,v) \in A, \label{eq:A*1}\\
    &h(t) = 0. \label{eq:A*2}
\end{align}

Although $h_v$ is a heuristic function,
optimal solutions (i.e.\ shortest path) can still be obtained under the following conditions.
\citet{Astar} state that the heuristic estimate function $h$ must be admissible and consistent.
Admissible means that the heuristic must never over-estimate the distance to the destination.
Consistent means that the estimated path length of a node to the destination must not be greater than the estimated path length of its predecessors (i.e.\ Equations~\eqref{eq:A*1} and \eqref{eq:A*2}).
These two conditions mean that 
if the heuristic estimate is smaller than or equal to the actual distance going to the destination,
then the optimal shortest path can always be found. 
In graphs that are measured by Euclidean distances,
the heuristic estimate $h_u$ is the straight Euclidean distance between node $u$ and destination $t$.

%Note a consistent heuristic is also admissible but not the opposite.
%\citet{Astar} proves if the heuristic function (such as using geographical coordinates and Euclidean distance) is admissible and consistent,
%then A* is guaranteed to find the correct shortest path with a better time performance by scanning less nodes and arcs.
%
To implement A* search,
Dijkstra's algorithm is modified.
When a node $v$ is about to be added to the priority queue,
the heuristic estimate $h_v$ is calculated.
Compared to Dijkstra's algorithm,
instead of inserting node $v$ with its distance label $d_v$,
we now insert with $d_v + h_v$.
By doing so,
nodes that are closer to the destination are now labelled first.

\subsection{A* search in traffic assignment}
In our traffic assignment problem,
geographical coordinates and Euclidean distances cannot be used.
This is because the length of the arcs are determined by the BPR link cost function,
where travel time on the link is based on the traffic flow in the current iteration.
It is important to note here that in the path equilibration algorithm for solving the traffic assignment problem,
the traffic flow changes in each iteration of the algorithm and so does the travel time.
When the traffic assignment is getting solved,
there are only two ways to obtain the travel time estimate from any given node to the destination.
They are either to use the travel time from the previous iteration,
or use zero-flow travel times.

At first glance one may use travel times from the previous iteration,
but this does not work.
This is because traffic flows can decrease from one iteration to the next.
The decreased traffic flows result in non-admissible travel times,
where some of the arc travel times from the previous iteration is longer than the current travel times.
Using these longer travel times from the previous iteration will overestimate the travel time for the current iteration,
the resulting shortest path is not guaranteed to be optimal any more.

Another option is to use zero-flow travel times for the heuristic estimates.
The estimates $h_v$ can be obtained from computing the shortest path tree for every node $v$ where the traffic flow of the entire network is set to 0.
So when solving for the shortest path of any O-D ($s-t$) pair when there are traffic flows,
$h_v$ is equivalent to the zero-flow travel time of the shortest path from node $v$ to destination $t$.
These computed zero-flow travel times are both admissible and consistent.
This can be shown by analysing the BPR link cost function shown in Figure~\ref{fig:flowfunction}.
The function is a monotonic non-decreasing function with the lowest value being the zero-flow travel times.
As traffic flows change from iteration to iteration,
the travel times can never be smaller than the zero-flow travel times so they will never be an overestimate.
This means zero-flow travel times can be used for the heuristic estimates, and the shortest path is guaranteed to be optimal.

Overall, A* search does not improve the worst case time complexity compared to Dijkstra's algorithm,
but it can improve the average case by scanning less nodes in the network.
It can be see that when $h_v = 0$ ($\forall v \in N$), A* search is equivalent to Dijkstra's algorithm.
A* search has been tested in various studies.
In the case of using road networks,
\citet{GoldbergLandmarks} conclude that A* search with Euclidean distance estimates does not improve the run time compared to Dijkstra's algorithm when using Euclidean distance estimates.
However, it is still worth a try in the context of solving the traffic assignment problem using zero-flow travel times for the heuristic estimates.

\section{Bidirectional A* search}
Since bidirectional search can be applied to Dijkstra's algorithm,
it can also be applied to A* search.
The bidirectional A* search can be described by two ellipsoids extending from the origin and destination respectively.
This is shown in Figure~\ref{fig:bidirectdiff},
where bidirectional A* search potentially has a smaller search area than the unidirectional version.

\begin{figure}[b]
    \tikzstyle{main node} = [circle, draw, text centered, minimum height=2.5em]
    \tikzstyle{big circle} = [ellipse, draw, dashed, text centered, minimum width=8em, minimum height=5em]
    \tikzstyle{small circle} = [ellipse, draw, dashed, text centered, minimum width=5.5em, minimum height=3.5em]
    \centering
    \begin{subfigure}[t]{.4\textwidth}
        \centering
        \begin{tikzpicture}[>=stealth', line width=1pt, auto, node distance=3cm]
            \node [main node] (s)  {s};
            \node [main node] (t) [right of=s] {t};

            \node [big circle] at ($(s)+(0.9,0)$) {};
        \end{tikzpicture}
        \caption{A* search}
    \end{subfigure}
    \begin{subfigure}[t]{.4\textwidth}
        \centering
        \begin{tikzpicture}[>=stealth', line width=1pt, auto, node distance=3cm]
            \node [main node] (s) {s};
            \node [main node] (t) [right of=s] {t};

            \node [small circle] at ($(s)+(0.4,0)$) {};
            \node [small circle] at ($(t)-(0.4,0)$) {};
            \node [big circle, white] at (s) {};
        \end{tikzpicture}
        \caption{bidirectional A* search}
    \end{subfigure}
    \caption{Difference between the scanned area of A* search and its bidirectional version}
    \label{fig:bidirectdiff}
\end{figure}

One may construct the algorithm with the same termination condition described in the bidirectional Dijkstra's algorithm section (Section~\ref{section:bidirectional}),
that is to stop the algorithm when the two frontiers of the searches meet.
But the problem with bidirectional A* search is that, due to its two independent searches,
it does not label the nodes permanently in the order of their distance from the origin \citep{Klunder}.
This can cause either wrong shortest path to be calculated or having the two search frontiers never meet.

\begin{comment}
\begin{figure}[H]
    \tikzstyle{main node} = [circle, draw, text centered, minimum height=2.5em]
    \tikzstyle{line} = [draw, -latex']
    \centering
    \begin{tikzpicture}[>=stealth', line width=1pt, auto, node distance=3cm]
        \node [main node] (s) at (0,0)  {s};
        \node [main node] (v) at (2,3)  {v};
        \node [main node] (w) at (7,4)  {w};
        \node [main node] (t) at (8,7)  {t};

        \path [line, dashed] (s) -- node [right] {$\pi_r(v)$} (v);
        \path [line, dashed] (s) -- node [right] {$\pi_r(w)$} (w);
        %\path [line, dashed] (v) -- (w);
        \path [line, dashed] (v) -- node {$\pi_f(v)$} (t);
        \path [line, dashed] (w) -- node [left] {$\pi_f(w)$} (t);

        \draw [line, out=300, in=200, bend left] (s.north) to node [left] {$c_{st}$} (v);
        \draw [line, out=70, in=45, bend right] (w.east) to node [right] {$c_{wt}$} (t.east);
        \draw [line] (v.east) to node [above] {$c_{vw}$} (w);
    \end{tikzpicture}
    \caption{Heuristic values for bidirectional A* search}
    \label{fig:bidirect_heuristic}
\end{figure}
\end{comment}

%The strategy is described as follows.
%The heuristic estimates need to translated to consistent functions first. 
%(see Figure~\ref{fig:bidirect_heuristic} for demonstrations of the notations).
The correct strategy for calculating the heuristic estimates and termination criterion is first published in \citet{Pohl}.
The heuristic calculation was later improved in \citet{Ikeda}.
\citet{Ikeda} demonstrates that two distinct admissible heuristic functions $\pi_f$ and $\pi_r$ for the forward and backward search are not consistent for the bidirectional search, but their average is both admissible and consistent.
Here $\pi_f(v)$ is the estimate of distance from node $v$ to destination $t$ in the forward search and $\pi_r(v)$ is the estimate of distance from origin $s$ to node $v$ in the backward search. 
The new heuristic estimate functions are:
\begin{align}
    p_f(v) = \frac{1}{2}(\pi_f(v)-\pi_r(v)) + \frac{\pi_r(t)}{2}, \\
    p_r(v) = \frac{1}{2}(\pi_r(v)-\pi_f(v)) + \frac{\pi_f(s)}{2}.
\end{align}
The constants $\frac{\pi_r(t)}{2}$ and $\frac{\pi_f(s)}{2}$ are added by \citet{GoldbergEPP} to provide better estimates.
These two modified heuristic estimates are now consistent and the frontiers of the two searches are guaranteed to meet.
The drawback of this modification is that they now provide worse bounds compared to the original $\pi$ values,
and the search area may now be larger than the unidirectional A* search.

\citet{GoldbergEPP} showed and proved a better stopping criterion compared to the one published in \citet{Pohl},
where bidirectional Dijkstra's termination criterion is extended.
Bidirectional A* search has to be stopped when
\begin{align}
    \text{top}_f + \text{top}_r \geq \mu + p_r(t).
\end{align}
Here $\mu$ is the best $s-t$ path seen so far during the search,
$\text{top}_f$ and $\text{top}_r$ are the minimum distance labels in the forward and backward search respectively (they are minimum valued elemented at the top (front) of the priority queues).

Bidirectional A* search with Euclidean distance heuristic estimates has been tested by different academics, e.g.\ \citet{Klunder} and \citet{Goldberg05}.
It is not evident whether bidirectional A* search can guarantee significant improvement,
as the result is heavily dependent on the configuration of the road network and the quality of the heuristic estimates.
Nevertheless, bidirectional A* search is implement and tested, the results can be found in Section~\ref{sec:allresults}.

\section{Pre-processing algorithms}
In the last two decades,
extensive research has been done on the idea of speeding up shortest path calculations using pre-calculated data.
They include A* search with landmarks \citep{GoldbergLandmarks}, reach-based pruning \citep{Goldberg} and Hierarchical search \citep{Ertl1998, Pearson}, etc.
These pre-processing techniques generally need to spend some time to pre-calculate the data required for speeding up the sub-sequent shortest path queries.

The next section discusses the A* search with landmarks,
and its drawback when applied to the traffic assignment problem.

\subsection{A* search with landmarks}
From Section~\ref{section:A*} follows that
different methods can be used to estimate the shortest path distance $h_v$ from node $v$ to a specified destination.
The landmarks algorithm developed by \citet{GoldbergLandmarks} is another way to obtain the heuristic estimates.
%In fact the class of A* search algorithms that use a feasible function (heuristic estimate) $\pi_t$ with $\pi_t(t) = 0$ as lower-bounding algorithms.
%\citet{GoldbergLandmarks} concludes that better lower bounds give better performance, 
%where landmarks with triangle inequalities can give a better lower bounds.
%To obtained the estimates,
%The procedure of the landmarks algorithm 
%Next we describe the procedure for the landmarks algorithm.
First a small set of landmarks need to be positioned in different locations on the graph,
shortest path trees are calculated for every landmark using Dijkstra's algorithm.
Heuristic estimates can now be obtained for every node in the graph using the shortest path trees of the landmarks,
Figure~\ref{fig:landmarks} demonstrates the calculation of the estimates using the two triangle inequalities when a landmark is either placed in front of the scanned node $v$ or behind the destination $t$.
The two triangle inequalities are:
\begin{align}
     \text{dist}(v, t) & \geq \textcolor{blue}{\text{dist}(L,t)-\text{dist}(L,v)}, \\
     \text{dist}(v, t) & \geq \textcolor{red}{\text{dist}(v,L)-\text{dist}(t,L)}.
\end{align}
The heuristic estimate to be used during A* search is the maximum over all landmarks:
\begin{equation}
  \text{dist}(v,t) \geq \max\{ \textcolor{blue}{\text{dist}(L,t)-\text{dist}(L,v)}, \textcolor{red}{\text{dist}(v,L)-\text{dist}(t,L)} \}.
\end{equation}
With these formulations, \citet{GoldbergLandmarks} concluded that it is best to place the landmarks in front of the origins or behind the destinations,
i.e.\ around the outer boundary of the graph.

\begin{figure}[!ht]
    \centering
    \tikzstyle{node} = [draw,circle,inner sep=0pt,outer sep=0pt, minimum width=3pt, fill=black]
    \tikzstyle{line} = [draw, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}]
    \begin{subfigure}[t]{.4\textwidth}
        \centering
        \begin{tikzpicture}[>=stealth', line width=1pt, auto, scale=0.9]
            \node [node, label={[xshift=5pt, yshift=0pt]$v$}] (v) at (0,0) {};
            \node [node, label={[xshift=5pt, yshift=0pt]$t$}] (t) at (4,0) {};
            \node [node, label={[xshift=5pt, yshift=0pt]$L$}] (L) at (-2,1) {};
            \path [line,blue] (L) -- (t);
            \path [line,blue] (L) -- (v);
            \path [line, dashed] (v) -- (t);
        \end{tikzpicture}
        \caption{Landmark placed before $v$}
    \end{subfigure}
    \hspace{1cm}
    \begin{subfigure}[t]{.4\textwidth}
        \centering
        \begin{tikzpicture}[>=stealth', line width=1pt ,auto, scale=0.9]
            \node [node, label={[xshift=5pt, yshift=0pt]$v$}] (v) at (0,0) {};
            \node [node, label={[xshift=5pt, yshift=0pt]$t$}] (t) at (4,0) {};
            \node [node, label={[xshift=5pt, yshift=0pt]$L$}] (L) at (6,1) {};
            \path [line,red] (v) -- (L);
            \path [line,red] (t) -- (L);
            \path [line, dashed] (v) -- (t);
        \end{tikzpicture}
        \caption{Landmark placed after $t$}
    \end{subfigure}
    \caption{Explanatory diagram for triangle inequality}
    \label{fig:landmarks}
\end{figure}

The landmarks algorithm requires to store all shortest path distances for all landmarks, memory may be an issue if there are many landmarks and the network is large.
Although the pre-processing stage of the landmarks algorithm can take a long time,
it was shown that the shortest path solving times are significantly faster than A* search using Euclidean distance estimates (results can be found in \citet{GoldbergLandmarks}).

For the equilibration algorithm of the traffic assignment,
it is unknown whether landmarks using zero-flow travel times can provide better estimates compared to Euclidean distances.
Furthermore, both pre-processing and shortest path solving time of this algorithm are heavily dependent on the quantity and placement of the landmarks,
which is another optimisation problem where different strategies and algorithms need to be studied.
Due to these two problems, landmarks algorithm is not investigated further for this project.
