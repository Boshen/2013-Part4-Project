\chapter{Problem Description}
In the previous chapter we have briefly talked about the
shortest path and the traffic assignment problem.
In this chapter, we give formal definition to these concepts,
as well as the idea of a data structure.
\section{Notations and Definitions}

\marginpar{TODO\\ref\\properly->}
Using notations from \citep{Klunder} and in the context
of transportation networks,
we denote $ \mathcal{G} = ( \mathcal{V}, \mathcal{A} ) $ for a directed graph,
where $ \mathcal{V} $ denotes the set of nodes (origins, destinations, and intersections)
and $ \mathcal{A} $ the set of arcs (roads);
we say $ \mathcal{A} $ is a subset of the set $ \{ (u, v)\, | \, u, v \in \mathcal{V} \} $ of all ordered pairs of nodes.
We denote the cardinality of $ \mathcal{V} $ be V and $ \mathcal{A} $ be A.
We assume that $ 1 \leq V < \infty $ and $ 0 \leq A < \infty $,
and that a function $ c : \mathcal{A} \rightarrow \mathbb{R} $ is given that assigns a cost (travel time) to any arc $ (u,v) \in \mathcal{A} $.
We write the costs of arc $(u, v)$ as: $ c((u, v)) = c_{uv} $.

The path inside a transportation network has to be a directed simple path, 
which is a sequence of nodes and arcs $ (u_1, (u_1, u_2), u_2, \cdots , (u_{k-1}, u_k), u_k ) $
such that $ (u_i, u_{i+1}) \in \mathcal{A}$ for $i = 1,\cdots,k-1$ and $u_i \neq u_j$ for all $ 1 \leq i < j \leq k$.
Note $u_1$ is the origin and $u_k$ is the destination of the path $P$, $u_1$ and $u_k$ together is called an O-D pair for this path.
In a transportation network,
these O-D pairs are often traffic zones for generating supplies and receiving demands,
indicating they are untravellable nodes.
Finally we denote cost of the whole path $C(P) := \sum_{(u,v)\in P} c_{vw}$.

\section{The Shortest Path Problem}
\marginpar{SPP}
The Shortest Path Problem (SPP) is the problem of finding the shortest path from a given origin $s$ (source) to some destination $t$ (target).
There are two types of SPP hat are going to
be analysed in this report:
a single-source SPP and a point to point SPP.
A single-source SPP solves the shortest path going from one origin to every other destinations in the network,
meanwhile a point to point SPP solves from one origin to a specific destination.

\begin{comment}
We assume the graph contains a path from node $s$  to node $t$,
as well as all arc lengths are positive.
For a real transportation network, all these assumptions are satisfied naturally; any transportation networks will have at least one O-D pair and
all arc lengths are travel times that are naturally positive.
\end{comment}

\begin{comment}
\section{Traffic Assignment}
Traffic Assignment (TA) is the problem of selecting paths between origins and destinations in a transportation network,
and identify how many travellers use each path.
The difficulties of TA lies within a realistic model of the travel times,
travel times are modelled by a non-linear function to capture congestion effects:
more traffic flow means more congestion leading to slower travel times.
\marginpar{TA}

\subsection{Path Equilibration}
\marginpar{mention\\user/system\\optimal?}
Path Equilibration (PE) is a method for solving the TA problem.
This method assumes all travellers are selfish and will always find the shortest (least travel time) path.
Initially all travel demand is assigned to the shortest path between each O-D pair based on zero-flow travel times.
Then the travel times are updated iteratively based on the new flows, 
assigning new shortest path and new flows in each iteration,
eventually the travel times will reach equilibrium and no better shortest path can be calculated,
resulting optimality.
For each iteration of PE,
the point to point SPP is solved for all O-D pairs in the network.

\marginpar{PE}

\subsection{Frank-Wolfe}
\end{comment}

\section{Data Structures}
A Data structure is a way for computers to store, update and manipulate intermediate results.
A good data structure can efficiently speed up the access of the stored data,
which means the performance of solving our shortest path problem does not only depend on the algorithm it self but also the data structure.
In this project,
two data structures are combined to improve the solving speed:
\begin{itemize}
    \item Forward Star (for the label correcting algorithm in Section~\ref{section:labelcorrectingalgorithm}),
    \item Heap (for the label setting algorithms in Section~\ref{section:labelsettingalgorithm} and onwards).
\end{itemize}
\subsection{Forward Star}\label{chap:forwardstar}
There is one common characteristic for all of the shortest path algorithms that is going to be discussed in Section~\ref{chapter:solvingspp}:
all arcs emanating from a given node need to be accessed.
An efficient way of visiting every node inside a network and access all their emanating arcs is to use the Forward Star data structure.
The advantage of using this data structure for storing the network is that
the time complexity for finding any node in the network and iterating through all the emanating arcs is $O(1)$.
The exact implementation of Forward Star is not going to be detailed in this report,
but the information can be found in Chapter 5.3 of Urban Transportation Networks \citep{Sheffi}.
This data structure has already been implemented by the second supervisor.
\marginpar{TODO reword}

\subsection{Priority Queue and Heap}
A priority queue is a data structure which sorts elements by their priority,
element with high priority is always retrieved first before an element with a lower priority.
In section~\ref{section:labelsettingalgorithm} and on wards,
a specific implementation of the priority queue is used:
min-heap tree (of which also have different types of implementation).
The idea of the min-heap tree is that the values of a parent node
is always less or equal to its parent node,
by maintaining this property,
the minimum valued element will always be on top,
and retrieving it has only $O(1)$ time complexity.
And for other operations such as adding, removing and updating a node in the heap is at most $O(\log(N))$.
So the heap data structure is very efficient at constantly adding a element and finding the current minimum value.
The impact and usage of this data structure will be mentioned again for label setting algorithm in section~\ref{section:labelsettingalgorithm}.

